[{"title":"初学FreeSWITCH(2)--初识","date":"2017-05-16T08:29:19.000Z","path":"2017/05/16/初学FreeSWITCH-2-初识/","text":"1、FreeSWITCH特性官方定义：世界上第一个跨平台的、伸缩性极好的、免费的、多协议的电话软交换平台！&emsp;&emsp;&emsp;从技术上讲，FreeSWITCH是一个B2BUA（Back to Back User Agent）,它作为一个背靠背的用户代理用来帮助通信的双方进行&emsp;&emsp;&emsp;实时的语音视频通信B2BUA：B2BUA（Back-to-Back User Agent，背靠背用户代理）是通讯网络中，使用SIP（Session Initiation Protocol，会话发起协&emsp;&emsp;&emsp;议）实现会话的一种逻辑实体。B2BUA作为SIP呼叫两端的用户代理，负责处理呼叫两端的所有SIP信令，从呼叫确立到终止全程&emsp;&emsp;&emsp;跟踪每个呼叫。允许 B2BUA 的操作者来提供值附加特征到这个呼叫。对 SIP 用户，B2BUA 在一边担当用户代理服务器（UAS），&emsp;&emsp;&emsp;在另一边（背靠背）担当用户代理客户机（UAC）。 2、windows FreeSWITCH下载、安装 （1）使用安装包安装&emsp;&emsp;&ensp;下载地址：http://files.freeswitch.org/windows/installer/ （32位选择x86目录，64位选择x64目录）&emsp;&emsp;&ensp;进入目录后，选择需要的版本（选择版本注意看版本号第二位，即次版本号，奇数位开发版，偶数为稳定版，第三位用作补丁和更&emsp;&emsp;&ensp;新的标识）下载，下载之后安装使用默认设置","tags":[{"name":"FreeSWITCH","slug":"FreeSWITCH","permalink":"http://yueshengwujie.cn/tags/FreeSWITCH/"},{"name":"SIP","slug":"SIP","permalink":"http://yueshengwujie.cn/tags/SIP/"}]},{"title":"初学FreeSWITCH(1)--PSTN与VoIP基础","date":"2017-05-16T02:56:47.000Z","path":"2017/05/16/初学FreeSWITCH-1-PSTN与VoIP基础/","text":"1、名词解释（1）FreeSWITCH：FreeSWITCH是一个开源的电话的软交换解决方案，包括一个软电话和软交换机用以提供语音和聊天的产品驱动。&emsp;&emsp;&ensp;FreeSWITCH 可以用作交换机引擎、PBX、多媒体网关以及多媒体服务器等。&emsp;&emsp;&ensp;FreeSWITCH的也提供了一个稳定的电话平台，许多广泛使用的免费电话就是在使用它开发的，但是它不支持视频通话。（2）PSTN：Public Switched Telephone Network，公共交换电话网络，即我们日常打电话所用的电话网络。（3）VoIP：Voice over Internet Protocol，即承载在ip网上的语音通信（例如：聊天软件的语音聊天） 2、电话号码区号 （1）固话长度：大省市（如北京、上海等）使用8位号码，其他小的省市使用7位号码（2）区号：固话区号一般长度为2到3位（注：所有区号前面的0，属于国内长途字冠，它本身不是区号的一部分，当然，一般人把0当&emsp;&emsp;&ensp;做区号的一部分），国内长途前面加一个0和区号，国际长途则需要在前面加两个0（3）国家号：中国国家号86，北京区号10，那么在国外呼叫一个北京号码需要拨打（86+10+号码），另外每个国家前面还有国际长途&emsp;&emsp;&ensp;字冠，因为各个国家有不同的国际长途字冠，所以同一用“+”号代替，即完整呼叫号为（+86 10 xxxxxxxx） 3、移动号码以及专用号段定义：移动号码，俗称手机号，具备可移动性以及漫游特性，都是以1开头，而且根据运营商不同，其开头三位数字也不同，前三位也&emsp;&emsp;&emsp;为运营商的专用号段，例如中国移动的134,135等，而后面8位为号码，共十一位，170为虚拟运营商的专用号段 4、模拟信号与数字信号（1）模拟信号：连续性，距离会导致信号衰减，所以需要放大信号，但是会噪声同时放大，导致信噪比下降，严重时甚至难以分辨（2）数字信号：离散性，根据抽样定理（当抽样频率是模拟信号最好频率的两倍，就能完全还原原来的模拟信号）转成数字信号 5、SIP是什么SIP，Session Initiation Protocol，会话发起协议，由IETF提出的IP电话信令协议，用于发起会话，它能控制多个参与者参加的多媒体会话的建立和终结，并能动态调整和修改会话属性 寄语这是新旅程的开始，我不期待终点，因为终点是结束，如果到达，剩下的只是回忆","tags":[{"name":"FreeSWITCH","slug":"FreeSWITCH","permalink":"http://yueshengwujie.cn/tags/FreeSWITCH/"},{"name":"PSTN","slug":"PSTN","permalink":"http://yueshengwujie.cn/tags/PSTN/"},{"name":"VoIP","slug":"VoIP","permalink":"http://yueshengwujie.cn/tags/VoIP/"}]},{"title":"自动生成java实体类的工具类","date":"2017-04-10T02:49:32.000Z","path":"2017/04/10/自动生成java实体类的工具类/","text":"写实体类的悲伤写一个java实体类，需要对着数据库的表来写，还要写注释，注解，虽然可以一键生成get和set方法，但是当表字段非常多的时候，真的是挺烦的一件事情，我一直信奉一个观念，能自动化的，就不要动手了，写代码也应该是一样，很多人都知道，mybatis提供的生成器，可以生成实体类啊，dao啊，还有xml，多方便，但是我开发的数据库的表的字段特殊啊，于是自己网上找个例子，然后照着写了一个，强行装逼，从此，实体类，dao，xml一键生成，完美！ 自动生成的本质所谓自动生成对应的类，其本质也是使用代码，拼凑java类的代码字符串内容，然后生成一个file，把内容流写入，在项目对应路径下直接生成一个需要的文件，当然，只适用于格式固定，有规律的类。 代码示例 （1）初始化全局常量，以及定义对应变量123456789101112131415161718192021222324252627/** * 数据库配置 */private final static String pgUrl = &quot;jdbc:postgresql://192.168.1.69:5432/test_db&quot;;private final static String username = &quot;dbuser&quot;;private final static String password = &quot;123456&quot;;/** * 包路径配置 */private final static String domain = &quot;com.test.domain&quot;;private final static String mapper = &quot;com.test.mapper&quot;;private final static String I_mapper = &quot;com.test.mapper&quot;;private final static String mapper_impl = &quot;com.test.mapper.impl&quot;;private final static String I_service = &quot;com.test.service&quot;;private final static String service_impl = &quot;com.test.service.impl&quot;;//表名private String tableNames = &quot;&quot;;// 全列名数组（没有做大小写转换,没有去除字段前缀）private String[] all_colnames;// 列名类型数组private String[] col_types; // 列注释数组private String[] col_remarks; // 是否需要导入包java.util.Dateprivate boolean is_util = false; //作者private String authors = &quot;lmshe&quot;; （2）获取数据库连接，并初始化相关变量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public void generatorUtils(String tableName,String author)&#123; tableNames = tableName; authors = author; Connection conn = null; PreparedStatement pstmt = null; try &#123; // 得到数据库连接 conn = DriverManager.getConnection(pgUrl, username, password); String strsql = &quot;select * from &quot; + tableName; pstmt = conn.prepareStatement(strsql); ResultSetMetaData rsmd = pstmt.getMetaData(); // 查询该表共有多少列，并初始化相关数组 int size = rsmd.getColumnCount(); all_colnames = new String[size]; col_types = new String[size]; col_remarks = new String[size]; //初始化列注释 DatabaseMetaData dbmd = conn.getMetaData(); ResultSet rs = dbmd.getColumns(null, null, tableName, null); int re = 0; while (rs.next()) &#123; String remarks = rs.getString(&quot;REMARKS&quot;);// 列描述 col_remarks[re] = remarks; re++; &#125; //初始化列名以及列的字段类型，同时初始化是否需要导入java.util.Date for (int i = 0; i &lt; rsmd.getColumnCount(); i++) &#123; all_colnames[i] = rsmd.getColumnName(i + 1); col_types[i] = rsmd.getColumnTypeName(i + 1); if (rsmd.getColumnTypeName(i + 1).equalsIgnoreCase(&quot;timestamp&quot;)) &#123; is_util = true; &#125; &#125; //生成domain实体类 createDomainUtils(); //生成sql的xml createMappingUtils(); //生成dao接口类 createIDaoUtils(); //生成dao实现类 createDaoImplUtils(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; （3）生成domain类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public void createDomainUtils() &#123; try &#123; String content = parseDomain(); String path = System.getProperty(&quot;user.dir&quot;) + &quot;/src/main/java/&quot; + domain.replaceAll(&quot;\\\\.&quot;, &quot;/&quot;); File file = new File(path); if (!file.exists()) &#123; file.mkdirs(); &#125; String resPath = path + &quot;/&quot; + initcap(tableNames.substring(2, tableNames.length())) + &quot;.java&quot;; FileUtils.writeStringToFile(new File(resPath), content); System.out.println(&quot;建立domain成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;private String parseDomain() &#123; StringBuffer sb = new StringBuffer(); sb.append(&quot;package &quot; + domain + &quot;;\\r\\n\\r\\n&quot;); //导入依赖包 if (is_util) &#123; sb.append(&quot;import java.util.Date;\\r\\n\\r\\n&quot;); &#125; sb.append(&quot;import javax.persistence.Column;\\r\\n&quot;); sb.append(&quot;import javax.persistence.Id;\\r\\n&quot;); sb.append(&quot;import javax.persistence.Table;\\r\\n\\r\\n&quot;); //添加注解 sb.append(&quot;/**\\r\\n&quot;); sb.append(&quot; *\\r\\n&quot;); sb.append(&quot; * @author &quot; + authors + &quot;\\r\\n&quot;); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String date = sf.format(new Date()); sb.append(&quot; * @time &quot; + date + &quot;\\r\\n&quot;); sb.append(&quot; * @desc \\r\\n&quot;); sb.append(&quot; */\\r\\n&quot;); //类主体 sb.append(&quot;@Table(name=\\&quot;&quot; + tableNames + &quot;\\&quot;)\\r\\n&quot;); sb.append(&quot;public class &quot; + initcap(tableNames.substring(2)) + &quot; &#123;\\r\\n\\r\\n&quot;); //生成属性 processAllAttrs(sb); sb.append(&quot;\\r\\n&quot;); //生成方法 processAllMethod(sb); sb.append(&quot;&#125;\\r\\n&quot;); return sb.toString();&#125;private void processAllMethod(StringBuffer sb) &#123; for (int i = 0; i &lt; all_colnames.length; i++) &#123; String allColname = all_colnames[i]; String colname = getCamelStr(allColname); if (colname.substring(0, 1).equals(&quot;f&quot;)) &#123; colname = colname.substring(1); &#125; sb.append(&quot;\\tpublic void set&quot; + initcap(colname) + &quot;(&quot; + sqlType2JavaType(col_types[i]) + &quot; &quot; + colname + &quot;)&#123;\\r\\n&quot;); sb.append(&quot;\\t\\tthis.&quot; + colname + &quot;=&quot; + colname + &quot;;\\r\\n&quot;); sb.append(&quot;\\t&#125;\\r\\n\\r\\n&quot;); sb.append(&quot;\\tpublic &quot; + sqlType2JavaType(col_types[i]) + &quot; get&quot; + initcap(colname) + &quot;()&#123;\\r\\n&quot;); sb.append(&quot;\\t\\treturn &quot; + colname + &quot;;\\r\\n&quot;); sb.append(&quot;\\t&#125;\\r\\n\\r\\n&quot;); &#125;&#125;private void processAllAttrs(StringBuffer sb) &#123; for (int i = 0; i &lt; all_colnames.length; i++) &#123; String remark = col_remarks[i]; if (remark != null) &#123; sb.append(&quot;\\t/**\\r\\n&quot;); sb.append(&quot;\\t * &quot; + remark + &quot;\\r\\n&quot;); sb.append(&quot;\\t */\\r\\n&quot;); &#125; String allColname = all_colnames[i]; String colname = getCamelStr(allColname); if (allColname.equals(&quot;id&quot;)) &#123; sb.append(&quot;\\t@Id\\r\\n&quot;); sb.append(&quot;\\t@Column(name = \\&quot;&quot;+allColname+&quot;\\&quot;)\\r\\n&quot;); &#125; else &#123; sb.append(&quot;\\t@Column(name=\\&quot;&quot; + allColname + &quot;\\&quot;)\\r\\n&quot;); &#125; if (colname.substring(0, 1).equals(&quot;f&quot;)) &#123; colname = colname.substring(1); &#125; sb.append(&quot;\\tprivate &quot; + sqlType2JavaType(col_types[i]) + &quot; &quot; + colname + &quot;;\\r\\n\\r\\n&quot;); &#125;&#125; （4）生成sql的xml12345678910111213141516171819202122232425262728293031323334353637383940public void createMappingUtils() &#123; try &#123; String content = parseMapping(); String path = System.getProperty(&quot;user.dir&quot;) + &quot;/src/main/java/&quot; + mapper.replaceAll(&quot;\\\\.&quot;, &quot;/&quot;); File file = new File(path); if (!file.exists()) &#123; file.mkdirs(); &#125; String resPath = path + &quot;/I&quot; + initcap(tableNames.substring(2, tableNames.length())) + &quot;Mapper.xml&quot;; FileUtils.writeStringToFile(new File(resPath), content); System.out.println(&quot;建立xml成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;private String parseMapping() &#123; StringBuffer sb = new StringBuffer(); sb.append(&quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;?&gt;\\r\\n&quot;); sb.append(&quot;&lt;!DOCTYPE mapper PUBLIC \\&quot;-//mybatis.org//DTD Mapper 3.0//EN\\&quot; \\&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\\&quot;&gt;\\r\\n\\r\\n&quot;); sb.append(&quot;&lt;mapper namespace=\\&quot;com.unionbon.youlb.http.mapper.I&quot;+initcap(tableNames.substring(2))+&quot;Mapper\\&quot;&gt;\\r\\n\\r\\n&quot;); sb.append(&quot;\\t&lt;resultMap id=\\&quot;BaseResultMap\\&quot; type=\\&quot;com.unionbon.youlb.http.domain.&quot;+initcap(tableNames.substring(2))+&quot;\\&quot;&gt;\\r\\n&quot;); for (int i = 0; i &lt; all_colnames.length; i++) &#123; String allColname = all_colnames[i]; String colname = getCamelStr(allColname); if (allColname.equals(&quot;id&quot;)) &#123; sb.append(&quot;\\t\\t&lt;id column=\\&quot;id\\&quot; property=\\&quot;id\\&quot; jdbcType=\\&quot;&quot;+sqlType2MybatisType(col_types[i])+&quot;\\&quot; /&gt;\\r\\n&quot;); &#125; else &#123; if (colname.substring(0, 1).equals(&quot;f&quot;)) &#123; colname = colname.substring(1); &#125; sb.append(&quot;\\t\\t&lt;result column=\\&quot;&quot;+allColname+&quot;\\&quot; property=\\&quot;&quot;+colname+&quot;\\&quot; jdbcType=\\&quot;&quot;+sqlType2MybatisType(col_types[i])+&quot;\\&quot; /&gt;\\r\\n&quot;); &#125; &#125; sb.append(&quot;\\t&lt;/resultMap&gt;\\r\\n&quot;); sb.append(&quot;&lt;/mapper&gt;&quot;); return sb.toString();&#125; （5）生成dao以及实现类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public void createIDaoUtils() &#123; try &#123; String content = parseIDao(); String path = System.getProperty(&quot;user.dir&quot;) + &quot;/src/main/java/&quot; + I_mapper.replaceAll(&quot;\\\\.&quot;, &quot;/&quot;); File file = new File(path); if (!file.exists()) &#123; file.mkdirs(); &#125; String resPath = path + &quot;/I&quot; + initcap(tableNames.substring(2, tableNames.length())) + &quot;Mapper.java&quot;; FileUtils.writeStringToFile(new File(resPath), content); System.out.println(&quot;建立dao接口类成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;private String parseIDao() &#123; StringBuffer sb = new StringBuffer(); sb.append(&quot;package &quot; + I_mapper + &quot;;\\r\\n\\r\\n&quot;); sb.append(&quot;import com.unionbon.youlb.http.mapper.IBaseMapper;\\r\\n&quot;); sb.append(&quot;import com.unionbon.youlb.http.domain.&quot;+initcap(tableNames.substring(2))+&quot;;\\r\\n\\r\\n&quot;); //添加注解 sb.append(&quot;/**\\r\\n&quot;); sb.append(&quot; *\\r\\n&quot;); sb.append(&quot; * @author &quot; + authors + &quot;\\r\\n&quot;); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String date = sf.format(new Date()); sb.append(&quot; * @time &quot; + date + &quot;\\r\\n&quot;); sb.append(&quot; * @desc \\r\\n&quot;); sb.append(&quot; */\\r\\n&quot;); //类主体 String idType = &quot;&quot;; for (int i = 0; i &lt; all_colnames.length; i++) &#123; String allColname = all_colnames[i]; if (allColname.equals(&quot;id&quot;)) &#123; idType = sqlType2JavaType(col_types[i]); break; &#125; &#125; sb.append(&quot;public interface I&quot; + initcap(tableNames.substring(2)) + &quot;Mapper extends IBaseMapper&lt;&quot;+initcap(tableNames.substring(2))+&quot;, &quot;+idType+&quot;&gt;&#123;\\r\\n\\r\\n&quot;); sb.append(&quot;&#125;\\r\\n&quot;); return sb.toString();&#125;public void createDaoImplUtils() &#123; try &#123; String content = parseDaoImpl(); String path = System.getProperty(&quot;user.dir&quot;) + &quot;/src/main/java/&quot; + mapper_impl.replaceAll(&quot;\\\\.&quot;, &quot;/&quot;); File file = new File(path); if (!file.exists()) &#123; file.mkdirs(); &#125; String resPath = path + &quot;/&quot; + initcap(tableNames.substring(2, tableNames.length())) + &quot;MapperImpl.java&quot;; FileUtils.writeStringToFile(new File(resPath), content); System.out.println(&quot;建立dao实现类成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;private String parseDaoImpl() &#123; StringBuffer sb = new StringBuffer(); sb.append(&quot;package &quot; + mapper_impl + &quot;;\\r\\n\\r\\n&quot;); sb.append(&quot;import com.unionbon.youlb.http.mapper.impl.BaseMapperImpl;\\r\\n&quot;); sb.append(&quot;import com.unionbon.youlb.http.mapper.I&quot;+initcap(tableNames.substring(2))+&quot;Mapper;\\r\\n&quot;); sb.append(&quot;import com.unionbon.youlb.http.domain.&quot;+initcap(tableNames.substring(2))+&quot;;\\r\\n\\r\\n&quot;); //添加注解 sb.append(&quot;/**\\r\\n&quot;); sb.append(&quot; *\\r\\n&quot;); sb.append(&quot; * @author &quot; + authors + &quot;\\r\\n&quot;); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String date = sf.format(new Date()); sb.append(&quot; * @time &quot; + date + &quot;\\r\\n&quot;); sb.append(&quot; * @desc \\r\\n&quot;); sb.append(&quot; */\\r\\n&quot;); //类主体 String idType = &quot;&quot;; for (int i = 0; i &lt; all_colnames.length; i++) &#123; String allColname = all_colnames[i]; if (allColname.equals(&quot;id&quot;)) &#123; idType = sqlType2JavaType(col_types[i]); break; &#125; &#125; sb.append(&quot;public class &quot; + initcap(tableNames.substring(2)) + &quot;MapperImpl extends BaseMapperImpl&lt;&quot;+initcap(tableNames.substring(2))+&quot;, &quot;+idType+&quot;&gt; implements I&quot;+initcap(tableNames.substring(2))+&quot;Mapper&#123;\\r\\n\\r\\n&quot;); sb.append(&quot;&#125;\\r\\n&quot;); return sb.toString();&#125; （6）工具方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 把输入字符串的首字母改成大写 * * @param str * @return */public static String initcap(String str) &#123; char[] ch = str.toCharArray(); if (ch[0] &gt;= &apos;a&apos; &amp;&amp; ch[0] &lt;= &apos;z&apos;) &#123; ch[0] = (char) (ch[0] - 32); &#125; return getCamelStr(new String(ch));&#125;/** * * @param s * @return * @author lmshe * @time 2017年3月30日 * @desc 处理下横杠，并转为大写 */public static String getCamelStr(String s) &#123; while (s.indexOf(&quot;_&quot;) &gt; 0) &#123; int index = s.indexOf(&quot;_&quot;); s = s.substring(0, index) + s.substring(index + 1, index + 2).toUpperCase() + s.substring(index + 2); &#125; return s;&#125;/** * * @param sqlType * @return * @author lmshe * @time 2017年3月30日 * @desc 数据库类型与java类型互转 */private String sqlType2JavaType(String sqlType) &#123; if (sqlType.equalsIgnoreCase(&quot;bit&quot;)) &#123; return &quot;bool&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;tinyint&quot;)) &#123; return &quot;byte&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;int2&quot;)) &#123; return &quot;short&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;int4&quot;) || sqlType.equals(&quot;serial&quot;)) &#123; return &quot;Integer&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;int8&quot;)) &#123; return &quot;Long&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;bigint&quot;)) &#123; return &quot;Long&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;float&quot;)) &#123; return &quot;float&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;decimal&quot;) || sqlType.equalsIgnoreCase(&quot;numeric&quot;) || sqlType.equalsIgnoreCase(&quot;real&quot;)) &#123; return &quot;double&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;money&quot;) || sqlType.equalsIgnoreCase(&quot;smallmoney&quot;)) &#123; return &quot;double&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;varchar&quot;) || sqlType.equalsIgnoreCase(&quot;char&quot;) || sqlType.equalsIgnoreCase(&quot;nvarchar&quot;) || sqlType.equalsIgnoreCase(&quot;nchar&quot;)) &#123; return &quot;String&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;timestamp&quot;)) &#123; return &quot;Date&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;image&quot;)) &#123; return &quot;Blob&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;text&quot;)) &#123; return &quot;Clob&quot;; &#125; return null;&#125;/** * * @param sqlType * @return * @author lmshe * @time 2017年3月31日 * @desc 数据库类型与mybatisxml的jdbc类型转换 */private String sqlType2MybatisType(String sqlType) &#123; if (sqlType.equalsIgnoreCase(&quot;int4&quot;) || sqlType.equals(&quot;serial&quot;)) &#123; return &quot;INTEGER&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;varchar&quot;)) &#123; return &quot;VARCHAR&quot;; &#125; else if (sqlType.equalsIgnoreCase(&quot;char&quot;))&#123; return &quot;CHAR&quot;; &#125;else if (sqlType.equalsIgnoreCase(&quot;timestamp&quot;)) &#123; return &quot;TIMESTAMP&quot;; &#125;else if(sqlType.equalsIgnoreCase(&quot;decimal&quot;))&#123; return &quot;DECIMAL&quot;; &#125; return null;&#125; （7）测试1234567891011121314151617/** * * * @author lmshe * @time 2017年3月30日 * @desc 代码生成器 */public class Generator &#123; //表名 private final static String tableName= &quot;t_users&quot;; //作者 private final static String author = &quot;lmshe&quot;; //生成代码仅适用于表主键字段名为“id”，且其它字段以“f”开始,且字段都以下横杠连接 public static void main(String[] args) &#123; new GeneratorUtils().generatorUtils(tableName,author); &#125;&#125; 寄语当人生活成了回忆，不过是在等待逝去，而只有不断创造回忆，才是人生精彩的演绎","tags":[{"name":"自动生成","slug":"自动生成","permalink":"http://yueshengwujie.cn/tags/自动生成/"},{"name":"java实体类","slug":"java实体类","permalink":"http://yueshengwujie.cn/tags/java实体类/"}]},{"title":"maven项目配置mybatis的一些问题记录","date":"2017-04-05T09:15:51.000Z","path":"2017/04/05/maven项目配置mybatis的一些问题记录/","text":"1、maven项目mybatis依赖包配置（使用3.3.0版本的mybatis）12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 2、mybatis配置文件 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt;&lt;!-- 别名配置，对应项目中的实体类，在sql.xml中可以直接使用别名对应到实体类 --&gt; &lt;typeAlias alias=&quot;User&quot; type=&quot;com.test.domain.User&quot; /&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt;&lt;!-- 数据库环境配置 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt;&lt;!-- 这种数据源的实现利用“池”的概念将JDBC连接对象组织起来， 避免了创建先的连接实例时所必须的初始化和认证时间。 这是一种使得并发WEb应用快速响应请求的流行的处理方式。 UNPOOLED - 这个数据源的实现只是每次请求时打开和关闭连接。 --&gt; &lt;property name=&quot;driver&quot; value=&quot;org.postgresql.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:postgresql://192.168.1.69:5432/li_db&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;dbuser&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 通过resource加载单个映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/unionbon/youlb/http/mapping/Base.xml&quot; /&gt; &lt;mapper resource=&quot;com/unionbon/youlb/http/mapping/User.xml&quot; /&gt; &lt;/mappers&gt; &lt;!-- 需要将mapper接口类名和mapper.xml映射文件名称保持一致且在同一个目录中， 注意：要使用的是mapper代理。两个文件要在同一个目录 --&gt;&lt;!-- &lt;mappers&gt; &lt;mapper class=&quot;com.test.mapping.UserMapper&quot; /&gt; &lt;/mappers&gt; --&gt; &lt;!-- 需要将mapper接口类名和mapper.xml映射文件名称保持一致且在同一个目录中， 注意：要使用的是mapper代理。两个文件要在同一个目录 --&gt;&lt;!-- &lt;mappers&gt; &lt;package name=&quot;com.test.mapping&quot; /&gt; &lt;/mappers&gt; --&gt;&lt;/configuration&gt; 文件为xml格式文件，可以直接放在maven项目的src/main/resources，这样读取的时候比较方便，configuration节点里面的子节点是有顺序的，例如：mappers不能放在typeAliases前面，子节点如果顺序有误，会报错，可将鼠标放在报错位置查看正确的子节点顺序。 3、读取mybatis配置文件，获取SqlSession1234567891011121314151617181920212223public static void main(String[] args)&#123; SqlSessionFactory sqlSessionFactory = null; SqlSession session = null; String resource = &quot;Configuration.xml&quot;;//配置文件所在路径 InputStream inputStream; try &#123; inputStream = Resources.getResourceAsStream(resource); //获取文件流 sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //建立SqlSessionFactory则只需要启动项目初始化一次就行。 session = sqlSessionFactory.openSession(); //获取SqlSession都是线程不安全的， System.out.println(session); User user = (User)session.selectOne(&quot;cn.bj.mybatis.models.UserMapper.selectUser&quot;,1); //调用查询方法 System.out.println(user.getId()); System.out.println(user.getUsername()); //非查询方法需手动提交session.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(session != null)&#123; session.close(); //关闭SqlSession &#125; &#125; &#125; 以上只是测试mybatis配置文件是否正确的方法，在项目中，需要进行简单的封装，而每一个SqlSession都是线程不安全的，SqlSessionFactory的工具类：则只需要启动项目初始化一次就行。SqlSessionFactory的工具类：123456789101112131415161718192021222324252627282930313233343536373839404142package com.test.utils;import java.io.Reader;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;/** * * * @author lmshe * @time 2017年3月28日 * @desc 初始化SqlSessionFactory */public class MyBatisUtil&#123; private MyBatisUtil()&#123; &#125; private static final String RESOURCE = &quot;mybatis-config.xml&quot;;//mybatis配置文件所在路径 private static SqlSessionFactory sqlSessionFactory = null; //使用静态块初始化SqlSessionFactory static &#123; Reader reader = null; try &#123; reader = Resources.getResourceAsReader(RESOURCE); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); sqlSessionFactory = builder.build(reader); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * * @return * @author lmshe * @time 2017年3月28日 * @desc 获取SqlSessionFactory */ public static SqlSessionFactory getSqlSessionFactory()&#123; return sqlSessionFactory; &#125;&#125; 4、mybatis的CRUD的简单封装对于spring MVC等主流框架项目来说，直接引入liuzh封装的Mapper，已经封装好大部分CRUD方法，当然更方便，但是由于本人项目是main函数启动，并没有使用spring MVC，所以在抉择下，决定参考网上资料，自己封装部分CRUD， （1）如何封装通用的BaseDaomybatis通过配置可以将sql.xml和dao映射起来，通过xml中的id，能执行xml中的sql，如果需要通用的方法，就需要使用泛型，然后产生CRUD的sql，直接传入xml中，执行，mybatis框架提供的可以将参数传入，使用#{参数名}来获取传入的参数，同时也提供了另一种方法，将sql传入，但是获取sql的方式与获取参数不同，使用${sql}，那么，重要的工作，就是如何使用泛型产生sql。 （2）定义BaseDao1234567891011121314151617181920212223242526272829303132333435363738package com.test.mapper;import java.util.List;public interface IBaseMapper&lt;T,PK&gt; &#123; /** * 根据主键删除记录 * 物理删除，无法恢复 */ int deleteByPrimaryKey(PK id); /** * 插入记录 * 字段为空，不插入 */ int insertSelective(T obj); /** * 根据主键更新记录 * 字段为空，不更新 */ int updateByPrimaryKeySelective(T obj); /** * 根据主键查询 * 此查询方法仅适用于表主键字段名为“id”，且其它字段以“f”开始 */ T selectByPrimaryKey(PK id); /** * 条件查询 * 此查询方法仅适用于表主键字段名为“id”，且其它字段以“f”开始 */ T selectByParams(T obj); /** * 条件查询 * 此查询方法仅适用于表主键字段名为“id”，且其它字段以“f”开始 */ List&lt;T&gt; selectList(T obj);&#125; （3）定义Base.xml12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.test.mapper.IBaseMapper&quot;&gt; &lt;!-- 删除数据 --&gt; &lt;delete id=&quot;deleteByPrimaryKey&quot;&gt; $&#123;value&#125; &lt;/delete&gt; &lt;!-- 插入数据 --&gt; &lt;insert id=&quot;insertSelective&quot;&gt; $&#123;value&#125; &lt;/insert&gt; &lt;!-- 根据主键更新记录 --&gt; &lt;update id=&quot;updateByPrimaryKeySelective&quot;&gt; $&#123;value&#125; &lt;/update&gt; &lt;!-- 根据主键查询记录 --&gt; &lt;select id=&quot;selectByPrimaryKey&quot; resultType=&quot;hashMap&quot;&gt; $&#123;value&#125; &lt;/select&gt; &lt;!-- 条件查询记录 --&gt; &lt;select id=&quot;selectByParams&quot; resultType=&quot;hashmap&quot;&gt; $&#123;value&#125; &lt;/select&gt; &lt;!-- 查询记录列表 --&gt; &lt;select id=&quot;selectList&quot; resultType=&quot;hashmap&quot;&gt; $&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; （4）BaseDao实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.test.mapper.impl;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.List;import java.util.Map;import org.mybatis.spring.support.SqlSessionDaoSupport;import com.test.mapper.IBaseMapper;import com.test.utils.MyBatisUtil;import com.test.utils.ReflectionUtils;import com.test.utils.SQLGeneratorUtils;public class BaseMapperImpl&lt;T,PK&gt; extends SqlSessionDaoSupport implements IBaseMapper&lt;T,PK&gt;&#123; SQLGeneratorUtils&lt;T, PK&gt; sqlGeneratorUtils = new SQLGeneratorUtils&lt;T, PK&gt;(); private Class&lt;T&gt; entityClass; @SuppressWarnings(&quot;unchecked&quot;) public BaseMapperImpl() &#123; super.setSqlSessionFactory(MyBatisUtil.getSqlSessionFactory()); Type genType = getClass().getGenericSuperclass(); Type[] params = ((ParameterizedType) genType).getActualTypeArguments(); entityClass = (Class&lt;T&gt;) params[0]; &#125; @Override public int deleteByPrimaryKey(PK id) &#123; String sql = sqlGeneratorUtils.deleteByPrimaryKey(entityClass,id); return this.getSqlSession().delete(&quot;deleteByPrimaryKey&quot;,sql); &#125; @Override public int insertSelective(T obj) &#123; String sql = sqlGeneratorUtils.insertSelective(obj); return this.getSqlSession().insert(&quot;insertSelective&quot;,sql); &#125; @Override public int updateByPrimaryKeySelective(T obj) &#123; String sql = sqlGeneratorUtils.updateByPrimaryKeySelective(obj); return this.getSqlSession().update(&quot;updateByPrimaryKeySelective&quot;,sql); &#125; @Override public T selectByPrimaryKey(PK id) &#123; String sql = sqlGeneratorUtils.selectByPrimaryKey(entityClass,id); Map&lt;String, Object&gt; resultMap = this.getSqlSession().selectOne(&quot;selectByPrimaryKey&quot;,sql); if(resultMap != null)&#123; return handleResult(resultMap,entityClass); &#125; return null; &#125; @Override public T selectByParams(T obj) &#123; String sql = sqlGeneratorUtils.selectByParams(obj); Map&lt;String, Object&gt; resultMap = this.getSqlSession().selectOne(&quot;selectByParams&quot;,sql); if(resultMap != null)&#123; return handleResult(resultMap,entityClass); &#125; return null; &#125; @Override public List&lt;T&gt; selectList(T obj) &#123; String sql = sqlGeneratorUtils.selectByParams(obj); List&lt;Map&lt;String,Object&gt;&gt; resultMapList = this.getSqlSession().selectList(&quot;selectList&quot;,sql); if(resultMapList != null)&#123; List&lt;T&gt; tList = new ArrayList&lt;T&gt;(resultMapList.size()); for (Map&lt;String, Object&gt; resultMap : resultMapList) &#123; T t = handleResult(resultMap, entityClass); tList.add(t); &#125; return tList; &#125; return null; &#125; /** * * @param resultMap * @param tClazz * @return * @author lmshe * @time 2017年3月31日 * @desc 处理查询结果 */ private T handleResult(Map&lt;String, Object&gt; resultMap, Class&lt;T&gt; tClazz) &#123; T t = null; try &#123; t = tClazz.newInstance(); &#125; catch (Exception e) &#123; logger.error(&quot;/********************************&quot;); logger.error(&quot;封装查询结果时，实例化对象(&quot; + this.entityClass + &quot;)时，出现异常!&quot; + e.getMessage()); logger.error(&quot;/********************************&quot;); &#125; for (Map.Entry&lt;String, Object&gt; entry : resultMap.entrySet()) &#123; String key = entry.getKey(); Object val = entry.getValue(); ReflectionUtils.invokeSetterMethod(t, key, val); &#125; return t; &#125;&#125; 关于基类Dao的实现，其实为了偷懒，而使用了spring的SqlSessionDaoSupport，不然每个方法都要开SqlSession，关SqlSession，烦死，由于没有使用spring配置，所以其实需要将SqlSessionFactory注入才可以正常调用，于是使用了构造方法来实现，这样就可以使用this.getSqlSession()来直接调用方法，而其中产生sql使用了另外一个工具类，关于实体类与泛型使用反射工具类来处理，将Map对象转成实体类对象 （5）产生sql工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231package com.test.utils;import java.lang.reflect.Field;import java.util.Date;import javax.persistence.Column;import javax.persistence.Id;import javax.persistence.Table;import org.apache.commons.lang.StringUtils;public class SQLGeneratorUtils&lt;T,PK&gt; &#123; /** * * @param id * @return * @author lmshe * @time 2017年3月29日 * @desc 根据id删除记录，兼容id为Integer */ public String deleteByPrimaryKey(Class&lt;T&gt; entityClass,PK id)&#123; String sql = &quot;&quot;; try &#123; Table table = entityClass.getAnnotation(Table.class); if(table == null)&#123; throw new RuntimeException(&quot;类-&quot;+ entityClass + &quot;,未用@Table注解标识!!&quot;); &#125; String tableName = table.name(); Field[] fields = entityClass.getDeclaredFields(); String pkName = &quot;&quot;; for(Field field : fields)&#123; field.setAccessible(true); if(field.getAnnotation(Id.class) != null)&#123; Column col = field.getAnnotation(Column.class); pkName = col.name(); break; &#125; &#125; if(StringUtils.isNotBlank(pkName))&#123; sql += &quot;DELETE FROM &quot; + tableName + &quot; where &quot; + pkName + &quot;=&quot; + handleValue(id); &#125; &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; return sql; &#125; /** * * @param obj * @return * @author lmshe * @time 2017年3月29日 * @desc 插入记录，字段不为空的插入 * */ public String insertSelective(T obj)&#123; String sql = &quot;&quot;; try &#123; Class&lt;?&gt; entityClass = obj.getClass(); Table table = entityClass.getAnnotation(Table.class); if(table == null)&#123; throw new RuntimeException(&quot;类-&quot;+ entityClass + &quot;,未用@Table注解标识!!&quot;); &#125; String tableName = table.name(); Field[] fields = entityClass.getDeclaredFields(); String columnsStr = &quot;&quot;; String paramStr = &quot;&quot;; for(Field field : fields)&#123; field.setAccessible(true); Object param = field.get(obj); Column col = field.getAnnotation(Column.class); if(param != null &amp;&amp; col != null)&#123; param = this.handleValue(param); columnsStr += &quot;,&quot;+col.name(); paramStr += &quot;,&quot;+param; &#125; &#125; sql += &quot;INSERT INTO &quot; + tableName + &quot;(&quot; + columnsStr.substring(1) + &quot;)values(&quot; + paramStr.substring(1) + &quot;)&quot;; &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return sql; &#125; /** * * @param obj * @return * @author lmshe * @time 2017年3月29日 * @desc 根据主键更新记录，字段为空，不更新 */ public String updateByPrimaryKeySelective(T obj)&#123; String sql = &quot;&quot;; try &#123; Class&lt;?&gt; entityClass = obj.getClass(); Table table = entityClass.getAnnotation(Table.class); if(table == null)&#123; throw new RuntimeException(&quot;类-&quot;+ entityClass + &quot;,未用@Table注解标识!!&quot;); &#125; String tableName = table.name(); Field[] fields = entityClass.getDeclaredFields(); String sqlStr = &quot;&quot;; String pkName = &quot;&quot;; Object pkValue = &quot;&quot;; for(Field field : fields)&#123; field.setAccessible(true); Object param = field.get(obj); Column col = field.getAnnotation(Column.class); if(field.getAnnotation(Id.class) != null)&#123; if(param != null &amp;&amp; col != null)&#123; pkValue = this.handleValue(param); pkName = col.name(); &#125;else&#123; throw new RuntimeException(&quot;主键不能为空！&quot;); &#125; &#125;else&#123; if(param != null &amp;&amp; col != null)&#123; param = this.handleValue(param); sqlStr += &quot;,&quot;+col.name() + &quot;=&quot;+param; &#125; &#125; &#125; sql += &quot;update &quot; + tableName + &quot; set &quot; + sqlStr.substring(1) + &quot; where &quot; + pkName + &quot;=&quot; + pkValue; &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return sql; &#125; /** * * @param entityClass * @param id * @return * @author lmshe * @time 2017年3月30日 * @desc 根据主键查询 */ public String selectByPrimaryKey(Class&lt;T&gt; entityClass,PK id)&#123; String sql = &quot;&quot;; try &#123; Table table = entityClass.getAnnotation(Table.class); if(table == null)&#123; throw new RuntimeException(&quot;类-&quot;+ entityClass + &quot;,未用@Table注解标识!!&quot;); &#125; String tableName = table.name(); Field[] fields = entityClass.getDeclaredFields(); String pkName = &quot;&quot;; for(Field field : fields)&#123; field.setAccessible(true); if(field.getAnnotation(Id.class) != null)&#123; Column col = field.getAnnotation(Column.class); pkName = col.name(); break; &#125; &#125; sql += &quot;select * from &quot; + tableName + &quot; where &quot; + pkName + &quot;=&quot; + handleValue(id); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; return sql; &#125; /** * * @param obj * @return * @author lmshe * @time 2017年3月30日 * @desc 条件查询 */ public String selectByParams(T obj)&#123; String sql = &quot;&quot;; try &#123; Class&lt;?&gt; entityClass = obj.getClass(); Table table = entityClass.getAnnotation(Table.class); if(table == null)&#123; throw new RuntimeException(&quot;类-&quot;+ entityClass + &quot;,未用@Table注解标识!!&quot;); &#125; String tableName = table.name(); Field[] fields = entityClass.getDeclaredFields(); String sqlWhereStr = &quot;&quot;; for(Field field : fields)&#123; field.setAccessible(true); Object param = field.get(obj); Column col = field.getAnnotation(Column.class); if(param != null &amp;&amp; col != null)&#123; param = this.handleValue(param); sqlWhereStr += &quot; and &quot;+col.name() + &quot;=&quot;+param; &#125; &#125; sql += &quot;select * from &quot; + tableName + &quot; where &quot; + sqlWhereStr.substring(4); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return sql; &#125; /** * * @param param * @return * @author lmshe * @time 2017年3月29日 * @desc 处理param */ private Object handleValue(Object param) &#123; if (param instanceof String || param instanceof Date) &#123; param = &quot;\\&apos;&quot; + param + &quot;\\&apos;&quot;; &#125;else if (param instanceof Boolean) &#123; Boolean v = (Boolean) param; param = v ? 1 : 0; &#125; return param; &#125;&#125; （6）反射工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299package com.test.utils;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.math.BigDecimal;import java.math.BigInteger;import java.sql.Timestamp;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.Map;import org.apache.commons.lang.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * Description:反射工具类 */public abstract class ReflectionUtils &#123; private static final Logger logger = LoggerFactory .getLogger(ReflectionUtils.class); /** * 缓存方法 */ private static final Map&lt;Class&lt;?&gt;, Method[]&gt; METHODS_CACHEMAP = new HashMap&lt;Class&lt;?&gt;, Method[]&gt;(); /** * 反射 取值、设值,合并两个对象(Field same only ) * * @param from * @param to */ public static &lt;T&gt; void copyProperties(T fromobj, T toobj, String... fieldspec) &#123; for (String filename : fieldspec) &#123; Object val = ReflectionUtils.invokeGetterMethod(fromobj, filename); ReflectionUtils.invokeSetterMethod(toobj, filename, val); &#125; &#125; /** * 调用Getter方法 * * @param obj * 对象 * @param propertyName * 属性名 * @return */ public static Object invokeGetterMethod(Object obj, String propertyName) &#123; String getterMethodName = &quot;get&quot; + capitalize(propertyName); return invokeMethod(obj, getterMethodName, null, null); &#125; /** * 调用Setter方法,不指定参数的类型 * * @param obj * @param propertyName * @param value */ public static void invokeSetterMethod(Object obj, String propertyName, Object value) &#123; invokeSetterMethod(obj, propertyName, value, null); &#125; /** * 调用Setter方法,指定参数的类型 * * @param obj * @param propertyName 字段名 * @param value * @param propertyType * 为空，则取value的Class */ public static void invokeSetterMethod(Object obj, String propertyName, Object value, Class&lt;?&gt; propertyType) &#123; value = handleValueType(obj,propertyName,value); propertyType = propertyType != null ? propertyType : value.getClass(); String setterMethodName = &quot;set&quot; + capitalize(propertyName); invokeMethod(obj, setterMethodName, new Class&lt;?&gt;[] &#123; propertyType &#125;, new Object[] &#123; value &#125;); &#125; private static Object handleValueType(Object obj, String propertyName, Object value)&#123; String getterMethodName = &quot;get&quot; + capitalize(propertyName); Class&lt;?&gt; argsType = value.getClass();; Class&lt;?&gt; returnType = obtainAccessibleMethod(obj, getterMethodName).getReturnType(); if(argsType == returnType)&#123; return value; &#125; if (returnType == Boolean.class) &#123; String temp = value.toString(); value = (StringUtils.isNotBlank(temp) &amp;&amp; Long.valueOf(temp) &gt; 0) ? true : false; &#125; else if (returnType == Long.class) &#123; value = Long.valueOf(value.toString()); &#125;else if(returnType == Date.class)&#123; try &#123; value = SimpleDateFormat.getDateInstance().parse(value.toString()); &#125; catch (ParseException e) &#123; logger.error(&quot;类型转型Timpestap--&gt;Date时，发生错误! &quot; + e.getMessage() + &quot;(&quot;+value.toString()+&quot;)&quot;); &#125; &#125; else if (returnType == Short.class) &#123; value = Short.valueOf(value.toString()); &#125; else if (returnType == BigDecimal.class) &#123; value = BigDecimal.valueOf(Long.valueOf(value.toString())); &#125; else if (returnType == BigInteger.class) &#123; value = BigInteger.valueOf(Long.valueOf(value.toString())); &#125; else if(returnType == String.class)&#123; value = String.valueOf(value); &#125;else if(returnType == Integer.class)&#123; value = Integer.valueOf(value.toString()); &#125; return value; &#125; public static void main(String[] args) throws Exception &#123; Timestamp ts = new Timestamp(System.currentTimeMillis()); System.out.println(SimpleDateFormat.getDateInstance().parse(ts.toString())); &#125; /** * 直接调用对象方法，忽视private/protected修饰符 * * @param obj * @param methodName * @param parameterTypes * @param params * @return */ public static Object invokeMethod(final Object obj, final String methodName, final Class&lt;?&gt;[] parameterTypes, final Object[] args) &#123; Method method = obtainAccessibleMethod(obj, methodName, parameterTypes); if (method == null) &#123; throw new IllegalArgumentException( &quot;Devkit: Could not find method [&quot; + methodName + &quot;] on target [&quot; + obj + &quot;].&quot;); &#125; try &#123; return method.invoke(obj, args); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 循环向上转型，获取对象的DeclaredMethod,并强制设置为可访问 如向上转型到Object仍无法找到，返回null * * 用于方法需要被多次调用的情况，先使用本函数先取得Method,然后调用Method.invoke(Object obj,Object... * args) * * @param obj * @param methodName * @param parameterTypes * @return */ public static Method obtainAccessibleMethod(final Object obj, final String methodName, final Class&lt;?&gt;... parameterTypes) &#123; Class&lt;?&gt; superClass = obj.getClass(); Class&lt;Object&gt; objClass = Object.class; for (; superClass != objClass; superClass = superClass.getSuperclass()) &#123; Method method = null; try &#123; method = superClass.getDeclaredMethod(methodName, parameterTypes); method.setAccessible(true); return method; &#125; catch (NoSuchMethodException e) &#123; // Method不在当前类定义，向上转型 &#125; catch (SecurityException e) &#123; // Method不在当前类定义，向上转型 &#125; &#125; return null; &#125; /** * 不能确定方法是否包含参数时，通过方法名匹配获得方法 * * @param obj * @param methodName * @return */ public static Method obtainMethod(final Object obj, final String methodName) &#123; Class&lt;?&gt; clazz = obj.getClass(); Method[] methods = METHODS_CACHEMAP.get(clazz); if (methods == null) &#123; // 尚未缓存 methods = clazz.getDeclaredMethods(); METHODS_CACHEMAP.put(clazz, methods); &#125; for (Method method : methods) &#123; if (method.getName().equals(methodName)) return method; &#125; return null; &#125; /** * 直接读取对象属性值 忽视private/protected修饰符，不经过getter函数 * * @param obj * @param fieldName * @return */ public static Object obtainFieldValue(final Object obj, final String fieldName) &#123; Field field = obtainAccessibleField(obj, fieldName); if (field == null) &#123; throw new IllegalArgumentException( &quot;Devkit: could not find field [&quot; + fieldName + &quot;] on target [&quot; + obj + &quot;]&quot;); &#125; Object retval = null; try &#123; retval = field.get(obj); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return retval; &#125; /** * 直接设置对象属性值 忽视private/protected修饰符，不经过setter函数 * * @param obj * @param fieldName * @param value */ public static void setFieldValue(final Object obj, final String fieldName, final Object value) &#123; Field field = obtainAccessibleField(obj, fieldName); if (field == null) &#123; throw new IllegalArgumentException( &quot;Devkit: could not find field [&quot; + fieldName + &quot;] on target [&quot; + obj + &quot;]&quot;); &#125; try &#123; field.set(obj, value); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; /** * 循环向上转型，获取对象的DeclaredField,并强制设为可访问 如向上转型Object仍无法找到，返回null * * @param obj * @param fieldName * @return */ public static Field obtainAccessibleField(final Object obj, final String fieldName) &#123; Class&lt;?&gt; superClass = obj.getClass(); Class&lt;Object&gt; objClass = Object.class; for (; superClass != objClass; superClass = superClass.getSuperclass()) &#123; try &#123; Field field = superClass.getDeclaredField(fieldName); field.setAccessible(true); return field; &#125; catch (NoSuchFieldException e) &#123; // Field不在当前类定义，向上转型 &#125; catch (SecurityException e) &#123; // Field不在当前类定义，向上转型 &#125; &#125; return null; &#125; /** * * @param str * @return * @author lmshe * @time 2017年3月31日 * @desc 处理属性字段 */ private static String capitalize(String str)&#123; if(!&quot;id&quot;.equals(str))&#123; while (str.indexOf(&quot;_&quot;) &gt; 0) &#123; int index = str.indexOf(&quot;_&quot;); str = str.substring(0, index) + str.substring(index + 1, index + 2).toUpperCase() + str.substring(index + 2); &#125; str = str.substring(1); &#125; return str = StringUtils.capitalize(str); &#125;&#125; 注意与参考由于本人的数据库表名是以t_开头，且所有字段名，都是用“f”开头，所以在使用反射工具类的时候，修改最后的capitalize()方法，适应自己用的表，如果已经在xml中配置了resultMap，则不需要在配置文件配置别名，适用与表字段名与实体类属性名不一致的情况 Mybatis封装简单的CRUD 寄语我低眉，藏起眼角的悲伤，笑颜渐起","tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yueshengwujie.cn/tags/mybatis/"},{"name":"maven","slug":"maven","permalink":"http://yueshengwujie.cn/tags/maven/"}]},{"title":"玩玩幻方","date":"2017-03-13T06:40:29.000Z","path":"2017/03/13/玩玩幻方/","text":"那些年玩过的数字游戏曾有一段时间，我疯狂的解幻方。从三阶开始，一阶一阶慢慢往上解。那时候甚至都不知道这个叫做幻方，反正是将1到n的平方填入到正方形的宫格中，横竖以及对角线都相等。当时的我没有任何资料，就随着自己的性子，一步步慢慢研究。然后自己总结出n阶幻方的和公式，n阶幻方的解法，n阶幻方的小规律。然而跟现在网上看到的各种规律完全不同。那时，最简单的是3阶幻方，甚至有时候数学考试都会有这个题目。直接把五填在中间，然后随便测试着摆一摆其它成对的数字，很容易算出来。就这样，我找上了四阶幻方，四阶幻方是偶数阶，跟奇数阶又不同，我还是偶然一次知道了要将1-16中间四个数字摆到中间四个格子，当然如何摆是有点小技巧的。然后是五阶，那时，我灵机一动，直接把三阶幻方的解放到了五阶幻方的中间，然后全部数字加上一个值，简单点说就是把1到9变成1-25中间的九个数字，这样，我要解的就只有最外一圈了，然后最外一圈的数字慢慢试（都是成对的，例如1和25,2和24…）最后我五阶解成功了，真是佩服自己的耐心。最后六阶，七阶，八阶，九阶，十阶，是的，最终我解到了十阶，连我自己都佩服当时的自己，最后我在一个笔记本上面，画下了所有的解。我现在都还记得，那是我初中最喜欢的一本笔记本，为了不让笔记本封面变脏，我买了透明胶布，手指宽的那种，然后一条一条，慢慢的将封面粘起来，用了很久，当时我满意极了，有时候自恋的默默笔记本的封面，有点滑，但是两个胶布之间还有一个小痕，摸起来感觉很不错。我还记得首页那里我画了一个超大的龙珠贝吉塔图，那是我根据一张卡片，慢慢按照比例放大，然后描到笔记本上，反正就摊开笔记本两页那么大。嗯，好像话题偏了。回到幻方，我一共十阶的幻方解，但是我只画了两个方格图，一个奇数阶幻方，一个偶数阶幻方，但是，估计也只有我看的懂，因为从内到外，除了三阶和四阶是全解，其它一层层都只是最外层的解，简单点说，两个图包含了3到10阶的幻方的所有解。可惜，现在都成为回忆了。 如果用算法解幻方网上百度了一下，那些算法好像都是根据幻方的规律来解的，也许你很奇怪别人如何随便就可以解出上百阶的幻方，我只能说，如果知道真相，你也可以做到。至于具体的，还是贴个百度百科的链接吧：关于幻方的由来和规律是不是很简单，然后前几天，我不是说要研究一下回溯法，然后我用回溯法写了一个解幻方的算法。三阶四阶都正常很快解出来了，五阶居然挂了，估计我写完这份博客都还没解出来。好吧，是我天真的，五阶的计算量太大，估计已经陷入死循环，毕竟回溯法这种探路算法，还是有点坑啊，也不知道自己是不是写的有点问题。 回溯算法解幻方代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233package test;import java.util.Scanner;public class MagicSquare &#123; /** 幻方总数 */ static int allNum = 0; /** 幻方阶数 */ static int n = 0; /** 幻方最大下角坐标 */ static int m = 0; /** 幻方行列对角和 */ static int count = 0; /** * 初始化幻方以及相关参数 * @return */ public int[][] initMgSq()&#123; n = (int) Math.sqrt(allNum); count = n*(n*n+1)/2; m = n-1; int[][] mgSq = new int[n][n]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; mgSq[i][j] = 0; &#125; &#125; System.out.println(&quot;阶数：&quot;+n); System.out.println(&quot;行列对角和：&quot;+count); return mgSq; &#125; /** * 解幻方，并打印结果 */ public void solve(int[][] mgSq) &#123; if (this.solve(mgSq, 0, 0)) &#123; printArray(mgSq); &#125; else &#123; System.out.println(&quot;没有找到相应的解法&quot;); &#125; &#125; /** * 解幻方 */ private boolean solve(int[][] mgSq, int row, int column) &#123; /** * 结束条件 */ if (row == m &amp;&amp; column == n) &#123; return true; &#125; /** * 如果column == n, 那么需要换行，也就需要更新column和row的值. */ if (column == n) &#123; column = 0; row++; &#125; /** * 如果当前位置上mgSq[row][column]的值为0, 尝试在1~allNum的数字中选择合适的数字 */ for (int num = 1; num &lt;= allNum; num++) &#123; if (isSafe(mgSq, row, column, num)) &#123; mgSq[row][column] = num; if (solve(mgSq, row, column + 1)) &#123; return true; &#125; mgSq[row][column] = 0; &#125; &#125; /** * 回溯重置 */ mgSq[row][column] = 0; return false; &#125; /** * 该数字是否已使用 */ private boolean isNumSafe(int[][] mgSq, int value) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if(mgSq[i][j] == value)&#123; return false; &#125; &#125; &#125; return true; &#125; /** * 某一行放置数据是否可以 */ private boolean isRowSafe(int[][] mgSq, int row, int value) &#123; int rowCount = value; for(int i : mgSq[row])&#123; rowCount += i; &#125; // 如果是行最后一个 ,判断这一行的和是否正确 if(mgSq[row][m-1] != 0)&#123; if(rowCount != count)&#123; return false; &#125; &#125;else&#123; if(rowCount &gt;= count)&#123; return false; &#125; &#125; return true; &#125; /** * 某一列放置数据是否可以 */ private boolean isColumnSafe(int[][] mgSq, int column, int value) &#123; int columnCount = value; for(int i=0;i&lt;n;i++)&#123; columnCount += mgSq[i][column]; &#125; // 如果是行最后一个 ,判断这一列的和是否正确 if(mgSq[m-1][column] != 0)&#123; if(columnCount != count)&#123; return false; &#125; &#125;else&#123; if(columnCount &gt;= count)&#123; return false; &#125; &#125; return true; &#125; /** * 对角是否可以放该数据 */ private boolean isOppositeSafe(int[][] mgSq, int row, int column, int value) &#123; //左右对角线和 int aCount = 0;//左 int bCount = 0;//右 if(row == column || (row + column) == m)&#123; //求对角线值 for(int i=0;i&lt;n;i++)&#123; aCount += mgSq[m-i][i]; bCount += mgSq[i][i]; &#125; //最后一行 if(row == m)&#123; if(column == 0 &amp;&amp; (aCount + value) != count)&#123; return false; &#125;else if(column == m &amp;&amp; (bCount + value) != count)&#123; return false; &#125; &#125;else if(row == column &amp;&amp; (row + column) == m)&#123;//中间点,偶数阶幻方无该坐标 if((aCount + value) &gt;= count || (bCount + value) &gt;= count)&#123; return false; &#125; &#125;else&#123; if(row == column)&#123; if((bCount + value) &gt;= count)&#123; return false; &#125; &#125;else&#123; if((aCount + value) &gt;= count)&#123; return false; &#125; &#125; &#125; &#125; return true; &#125; /** * 在指定位置是否可以放置数据 */ private boolean isSafe(int[][] mgSq, int row, int column, int value) &#123; if(this.isNumSafe(mgSq, value))&#123; if(this.isRowSafe(mgSq, row, value))&#123; if(this.isColumnSafe(mgSq, column, value))&#123; if(this.isOppositeSafe(mgSq, row, column, value))&#123; return true; &#125; &#125; &#125; &#125; return false; &#125; /** * 打印二维数组到控制台 */ private void printArray(int[][] mgSq) &#123; System.out.println(&quot;------------------------&quot;); for (int i = 0; i &lt; n; i++) &#123; System.out.print(&quot;|&quot;); for (int j = 0; j &lt; n; j++) &#123; System.out.print(&quot; &quot;); System.out.print(mgSq[i][j]+&quot; &quot;); if(mgSq[i][j]&lt;10)&#123; System.out.print(&quot; &quot;); &#125; System.out.print(&quot;|&quot;); &#125; System.out.println(&quot;&quot;); &#125; System.out.println(&quot;------------------------&quot;); &#125; /** * 测试 * @param args */ public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); allNum = sc.nextInt(); double d = Math.sqrt(allNum); String dStr = String.valueOf(d); dStr = dStr.substring(dStr.indexOf(&quot;.&quot;) +1); if(allNum &lt; 9 || !dStr.equals(&quot;0&quot;))&#123; System.out.println(&quot;请输入正确的幻方数字，例如：9,16...&quot;); &#125;else&#123; MagicSquare example = new MagicSquare(); int[][] mgSq = example.initMgSq(); example.solve(mgSq); &#125; &#125;&#125; 寄语我俯身，捧起脑海中记忆的浪花，藏进了心中","tags":[{"name":"幻方","slug":"幻方","permalink":"http://yueshengwujie.cn/tags/幻方/"},{"name":"回溯算法","slug":"回溯算法","permalink":"http://yueshengwujie.cn/tags/回溯算法/"}]},{"title":"数独算法——囧记","date":"2017-03-08T07:35:36.000Z","path":"2017/03/08/数独算法——囧记/","text":"自以为的骄傲我比较喜欢数独，也偶尔会玩一下，突然，有一天就萌生一个想法，写一个数独算法，于是网上一搜，发现好多算法，有些看着，好像很简陋，有些看着，好吧，看不懂，不如自己摸索一个。我花了一点时间，开始思考如何解出一个数独。用程序模拟自己平时解数独的习惯，然后暴力破解，最后，我只能想到这个方法。于是，我在纸上写下了几个解数独的步骤，总结分为三步，只要完成这三步，相信可以解出大部分不是骨灰级的数独。————————————分割线———————————-数独是共有9*9共81格的填数字游戏，行：填入1-9无重复，列：填入1-9无重复，宫（分为九个宫，一宫九格）：填入1-9无重复这是数独的基本规则，我的解法：我的数独算法博客链接 粉碎的小骄傲 今天，看了两位大神的博客，第一篇数独算法博客比我的妙多了，这是我的看法，首先，这篇博客让我知道了一个知识，看到的时候，我只能感慨自己的无知1List&lt;Integer&gt;[][] dataLeft = new ArrayList[9][9]; 就是上面这一句代码，让我突然间醒悟，原来数组还可以这样子用，或者说，之前int[9][9]局限了我的思维，我一直以为二维数组，只能填入数字，直到这句代码的出现，才知道，原来二维数组还可以这样子用。作者解数独的思维其实很简单，他创建了一个二维数组（A），每个坐标存储的是一个list，当然这个二维数组对应了另一个二维数组（数独数组：B），作者初始化A数组的时候，为每个坐标的list添加了数字1-9，即每个数独坐标可填入的所有数字。然后，作者从第一个坐标位开始判断，如果数独有值，则清除A中该坐标的list，并且清除该坐标行、列、宫所有list的这个值，1、最后判断A数组中所有list的长度，如果为1，表示找到一个正解，2、而长度不是1的，则判断行、列、宫内是否只出现了一次，如果是，获得一个正解3、最后判断单个宫内（可填值list长度不为1的），某个数字如果只在某一行（或者某一列）出现，那么可以排除另外两个宫，该行（或该列），无法填入该值A作者数独算法博客链接 另外一位大神则是回溯法解数独，简单点说，就是从第一个需要解值的位置开始，随意填入一个可填入的数字，然后下一个位置也是如此，一直填下去，如果出现错误，则回溯，如果没有，一直下去，直到解出数独。当然，核心还是对于行列宫的判断B作者数独算法博客链接 内心独白这两个算法都让我深深收到打击，不要说这么悲伤的事实，我还是有很大进步空间的。然后，你奇怪我为什么A大神写那么多，B大神写那么少，虽然算法都比我厉害，但是我个人还是觉得回溯法厉害一点，暴力的美学，深度优先的优雅，你值得拥有。 最后回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试，也叫试探法，我决定深度研究一下这个算法。 寄语有时候我们执着于自己的骄傲，却不知道，这恰恰局限了未来","tags":[{"name":"数独","slug":"数独","permalink":"http://yueshengwujie.cn/tags/数独/"},{"name":"算法","slug":"算法","permalink":"http://yueshengwujie.cn/tags/算法/"}]},{"title":"学习博客收集","date":"2017-03-07T09:52:48.000Z","path":"2017/03/07/学习博客收集/","text":"前端Emmet: HTML/CSS代码快速编写神器颜色表及html代码js中Math.random()生成指定范围数值的随机数 java使用Spring MVC,Mybatis框架等创建Java Web项目时各种前期准备的配置文件内容Maven仓库配置（全）java日志处理组件log4j–log4j.xml配置详解JAVA中经典快捷键(必看)和一些程序代码Java编码优化10技巧利用POI将word转换成html实现在线阅读poi完美word转html(表格、图片、样式)java实现在线预览-poi实现word、excel、ppt转html c#C#中Abstract和VirtualJava程序员的C#入门教程 - 开发环境搭建 giteclipse中git分支创建与合并（-）[Git高级教程 (一)] 通过Tag标签回退版本修复bug PostgreSQL关于PreparedStatement.addBatch()方法（事务）PostgreSQL学习手册(SQL语言函数)PostgreSQL函数如何返回数据集PostgreSQL学习手册(函数和操作符&lt;一&gt;) other聚合数据–手机固话来电显示多渠道获取手机归属地PM25天气信息开发APIm12 安装ubuntu15.10详细图文教程 虚拟机安装ubuntu安装 ubuntu更新软件 ubuntu一直卡在下载语言怎么办?Google hostsJSON格式化在线工具在线代码格式化 寄语很多人说成长是在抛弃以前懵懂无知的天真，其实不过是在不断的把自己变得复杂","tags":[{"name":"工具","slug":"工具","permalink":"http://yueshengwujie.cn/tags/工具/"}]},{"title":"hexo笔记","date":"2017-03-07T02:12:49.000Z","path":"2017/03/07/hexo笔记/","text":"开始的开始一开始成为javaer，并不知道有个人博客的这种东西。后来入行了，慢慢了解更多，知道了有个人博客，然而并没有觉得自己也需要一个属于自己的博客。只是突然间，在16年初，和朋友好奇之下买了域名，用github搭建了一个个人博客。而当时我的博客，还是直接把别人的fork下来，然后放上去。懵懂无知的直接修改主页的内容，不知道需要去配置文件里面修改配置。弄着弄着，也就放弃了，可以说甚至还没有开始。 另一个开始这一段时间，收到了好多次阿里云域名快失效的邮件，从一开始的不愿意理会，到后来，不知怎的，就上去续了费，也是突然才记得，自己有一个已经开了一年的个人博客，于是，重新开始了个人博客之路，也许会夭折，但绝不是现在，也非常感谢一位大神提供的开源主题。传送门：大神的博客 正餐 环境工具：git,node.js,hexo,Sublime搭建过程：1、git里面Create a new repository（新建仓库），名字为git用户名.github.io，例如我的：yueshengwujie.github.io2、DNS绑定域名（网上教程），github中最简单做法，直接添加一个名为CNAME的文件（无后缀），里面直接填写域名3、配置SSH key，ssh-keygen -t rsa -C “邮件地址”生成密钥，找到用户目录下.ssh\\id_rsa.pub文件，直接打开复制内容到github中的个人设置 -&gt; SSH and GPG keys -&gt; New SSH key4、git bash中操作指令(随便一个文件目录下操作)123456$ npm install -g hexo # 安装hexo$ hexo init # 初始化$ hexo g # 生成$ hexo s # 启动服务，本地浏览器访问[http://localhost:4000]$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia # 下载主题，个人比较喜欢的主题，也是我现在的主题$ hexo d # 发布上传到git 5、配置文件的修改主目录的_config.yml配置文件的修改1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia # 主题修改，将主题修改为theme目录下你喜欢的主题的文件夹的名字 下面配置关联github与本地仓库1234deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git # 注意使用git ssh，不要用https branch: master # 注意每个配置键值之间有一个空格分开 配置好以后安装一个必备插件1npm install hexo-deployer-git --save 6、常用的hexo命令12345678910111213$ hexo new &quot;postName&quot; #新建文章$ hexo new page &quot;pageName&quot; #新建页面$ hexo generate #生成静态页面至public目录$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）$ hexo deploy #部署到GitHub$ hexo help # 查看帮助$ hexo version #查看Hexo的版本# 缩写$ hexo n == $ hexo new$ hexo g == $ hexo generate$ hexo s == $ hexo server$ hexo d == $ hexo deploy 7、关于_config.yml配置文件的修改该配置文件在主目录下有一个，在themes/yilia目录下也有一个，后一个是相关于主题的配置。如果要添加一些静态资源，如图片，可以回到根目录下的source目录下添加一个文件夹photo，然后将图片放入，则可以在博客中使用”![图片描述](/photo/xxx.jpg)”直接插入 此篇博客只做简单的记录，关于一些详细的教程，相信网上已经有很多教程。个人配置参考源码 参考博文hexo博客添加图片，音乐，视频yilia主题源码Markdown 编辑器语法指南(Sublime)使用hexo+github搭建免费个人博客详细教程 寄语文字的美，不仅仅是文明的传承，更是镌刻着这个世界的曾经拥有","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yueshengwujie.cn/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://yueshengwujie.cn/tags/markdown/"}]},{"title":"真正开始的博客之路","date":"2017-03-06T10:01:28.000Z","path":"2017/03/06/真正开始的博客之路/","text":"寄语如果开始，那就不要轻易放弃，也许这就是梦想开始的地方","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yueshengwujie.cn/tags/随笔/"}]}]