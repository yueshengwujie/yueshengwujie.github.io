[{"title":"玩玩幻方","date":"2017-03-13T06:40:29.000Z","path":"2017/03/13/玩玩幻方/","text":"那些年玩过的数字游戏曾有一段时间，我疯狂的解幻方。从三阶开始，一阶一阶慢慢往上解。那时候甚至都不知道这个叫做幻方，反正是将1到n的平方填入到正方形的宫格中，横竖以及对角线都相等。当时的我没有任何资料，就随着自己的性子，一步步慢慢研究。然后自己总结出n阶幻方的和公式，n阶幻方的解法，n阶幻方的小规律。然而跟现在网上看到的各种规律完全不同。那时，最简单的是3阶幻方，甚至有时候数学考试都会有这个题目。直接把五填在中间，然后随便测试着摆一摆其它成对的数字，很容易算出来。就这样，我找上了四阶幻方，四阶幻方是偶数阶，跟奇数阶又不同，我还是偶然一次知道了要将1-16中间四个数字摆到中间四个格子，当然如何摆是有点小技巧的。然后是五阶，那时，我灵机一动，直接把三阶幻方的解放到了五阶幻方的中间，然后全部数字加上一个值，简单点说就是把1到9变成1-25中间的九个数字，这样，我要解的就只有最外一圈了，然后最外一圈的数字慢慢试（都是成对的，例如1和25,2和24…）最后我五阶解成功了，真是佩服自己的耐心。最后六阶，七阶，八阶，九阶，十阶，是的，最终我解到了十阶，连我自己都佩服当时的自己，最后我在一个笔记本上面，画下了所有的解。我现在都还记得，那是我初中最喜欢的一本笔记本，为了不让笔记本封面变脏，我买了透明胶布，手指宽的那种，然后一条一条，慢慢的将封面粘起来，用了很久，当时我满意极了，有时候自恋的默默笔记本的封面，有点滑，但是两个胶布之间还有一个小痕，摸起来感觉很不错。我还记得首页那里我画了一个超大的龙珠贝吉塔图，那是我根据一张卡片，慢慢按照比例放大，然后描到笔记本上，反正就摊开笔记本两页那么大。嗯，好像话题偏了。回到幻方，我一共十阶的幻方解，但是我只画了两个方格图，一个奇数阶幻方，一个偶数阶幻方，但是，估计也只有我看的懂，因为从内到外，除了三阶和四阶是全解，其它一层层都只是最外层的解，简单点说，两个图包含了3到10阶的幻方的所有解。可惜，现在都成为回忆了。 如果用算法解幻方网上百度了一下，那些算法好像都是根据幻方的规律来解的，也许你很奇怪别人如何随便就可以解出上百阶的幻方，我只能说，如果知道真相，你也可以做到。至于具体的，还是贴个百度百科的链接吧：关于幻方的由来和规律是不是很简单，然后前几天，我不是说要研究一下回溯法，然后我用回溯法写了一个解幻方的算法。三阶四阶都正常很快解出来了，五阶居然挂了，估计我写完这份博客都还没解出来。好吧，是我天真的，五阶的计算量太大，估计已经陷入死循环，毕竟回溯法这种探路算法，还是有点坑啊，也不知道自己是不是写的有点问题。 回溯算法解幻方代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233package test;import java.util.Scanner;public class MagicSquare &#123; /** 幻方总数 */ static int allNum = 0; /** 幻方阶数 */ static int n = 0; /** 幻方最大下角坐标 */ static int m = 0; /** 幻方行列对角和 */ static int count = 0; /** * 初始化幻方以及相关参数 * @return */ public int[][] initMgSq()&#123; n = (int) Math.sqrt(allNum); count = n*(n*n+1)/2; m = n-1; int[][] mgSq = new int[n][n]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; mgSq[i][j] = 0; &#125; &#125; System.out.println(&quot;阶数：&quot;+n); System.out.println(&quot;行列对角和：&quot;+count); return mgSq; &#125; /** * 解幻方，并打印结果 */ public void solve(int[][] mgSq) &#123; if (this.solve(mgSq, 0, 0)) &#123; printArray(mgSq); &#125; else &#123; System.out.println(&quot;没有找到相应的解法&quot;); &#125; &#125; /** * 解幻方 */ private boolean solve(int[][] mgSq, int row, int column) &#123; /** * 结束条件 */ if (row == m &amp;&amp; column == n) &#123; return true; &#125; /** * 如果column == n, 那么需要换行，也就需要更新column和row的值. */ if (column == n) &#123; column = 0; row++; &#125; /** * 如果当前位置上mgSq[row][column]的值为0, 尝试在1~allNum的数字中选择合适的数字 */ for (int num = 1; num &lt;= allNum; num++) &#123; if (isSafe(mgSq, row, column, num)) &#123; mgSq[row][column] = num; if (solve(mgSq, row, column + 1)) &#123; return true; &#125; mgSq[row][column] = 0; &#125; &#125; /** * 回溯重置 */ mgSq[row][column] = 0; return false; &#125; /** * 该数字是否已使用 */ private boolean isNumSafe(int[][] mgSq, int value) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if(mgSq[i][j] == value)&#123; return false; &#125; &#125; &#125; return true; &#125; /** * 某一行放置数据是否可以 */ private boolean isRowSafe(int[][] mgSq, int row, int value) &#123; int rowCount = value; for(int i : mgSq[row])&#123; rowCount += i; &#125; // 如果是行最后一个 ,判断这一行的和是否正确 if(mgSq[row][m-1] != 0)&#123; if(rowCount != count)&#123; return false; &#125; &#125;else&#123; if(rowCount &gt;= count)&#123; return false; &#125; &#125; return true; &#125; /** * 某一列放置数据是否可以 */ private boolean isColumnSafe(int[][] mgSq, int column, int value) &#123; int columnCount = value; for(int i=0;i&lt;n;i++)&#123; columnCount += mgSq[i][column]; &#125; // 如果是行最后一个 ,判断这一列的和是否正确 if(mgSq[m-1][column] != 0)&#123; if(columnCount != count)&#123; return false; &#125; &#125;else&#123; if(columnCount &gt;= count)&#123; return false; &#125; &#125; return true; &#125; /** * 对角是否可以放该数据 */ private boolean isOppositeSafe(int[][] mgSq, int row, int column, int value) &#123; //左右对角线和 int aCount = 0;//左 int bCount = 0;//右 if(row == column || (row + column) == m)&#123; //求对角线值 for(int i=0;i&lt;n;i++)&#123; aCount += mgSq[m-i][i]; bCount += mgSq[i][i]; &#125; //最后一行 if(row == m)&#123; if(column == 0 &amp;&amp; (aCount + value) != count)&#123; return false; &#125;else if(column == m &amp;&amp; (bCount + value) != count)&#123; return false; &#125; &#125;else if(row == column &amp;&amp; (row + column) == m)&#123;//中间点,偶数阶幻方无该坐标 if((aCount + value) &gt;= count || (bCount + value) &gt;= count)&#123; return false; &#125; &#125;else&#123; if(row == column)&#123; if((bCount + value) &gt;= count)&#123; return false; &#125; &#125;else&#123; if((aCount + value) &gt;= count)&#123; return false; &#125; &#125; &#125; &#125; return true; &#125; /** * 在指定位置是否可以放置数据 */ private boolean isSafe(int[][] mgSq, int row, int column, int value) &#123; if(this.isNumSafe(mgSq, value))&#123; if(this.isRowSafe(mgSq, row, value))&#123; if(this.isColumnSafe(mgSq, column, value))&#123; if(this.isOppositeSafe(mgSq, row, column, value))&#123; return true; &#125; &#125; &#125; &#125; return false; &#125; /** * 打印二维数组到控制台 */ private void printArray(int[][] mgSq) &#123; System.out.println(&quot;------------------------&quot;); for (int i = 0; i &lt; n; i++) &#123; System.out.print(&quot;|&quot;); for (int j = 0; j &lt; n; j++) &#123; System.out.print(&quot; &quot;); System.out.print(mgSq[i][j]+&quot; &quot;); if(mgSq[i][j]&lt;10)&#123; System.out.print(&quot; &quot;); &#125; System.out.print(&quot;|&quot;); &#125; System.out.println(&quot;&quot;); &#125; System.out.println(&quot;------------------------&quot;); &#125; /** * 测试 * @param args */ public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); allNum = sc.nextInt(); double d = Math.sqrt(allNum); String dStr = String.valueOf(d); dStr = dStr.substring(dStr.indexOf(&quot;.&quot;) +1); if(allNum &lt; 9 || !dStr.equals(&quot;0&quot;))&#123; System.out.println(&quot;请输入正确的幻方数字，例如：9,16...&quot;); &#125;else&#123; MagicSquare example = new MagicSquare(); int[][] mgSq = example.initMgSq(); example.solve(mgSq); &#125; &#125;&#125; 寄语我俯身，捧起脑海中记忆的浪花，藏进了心中","tags":[{"name":"幻方","slug":"幻方","permalink":"http://yueshengwujie.cn/tags/幻方/"},{"name":"回溯算法","slug":"回溯算法","permalink":"http://yueshengwujie.cn/tags/回溯算法/"}]},{"title":"数独算法——囧记","date":"2017-03-08T07:35:36.000Z","path":"2017/03/08/数独算法——囧记/","text":"自以为的骄傲我比较喜欢数独，也偶尔会玩一下，突然，有一天就萌生一个想法，写一个数独算法，于是网上一搜，发现好多算法，有些看着，好像很简陋，有些看着，好吧，看不懂，不如自己摸索一个。我花了一点时间，开始思考如何解出一个数独。用程序模拟自己平时解数独的习惯，然后暴力破解，最后，我只能想到这个方法。于是，我在纸上写下了几个解数独的步骤，总结分为三步，只要完成这三步，相信可以解出大部分不是骨灰级的数独。————————————分割线———————————-数独是共有9*9共81格的填数字游戏，行：填入1-9无重复，列：填入1-9无重复，宫（分为九个宫，一宫九格）：填入1-9无重复这是数独的基本规则，我的解法：我的数独算法博客链接 粉碎的小骄傲 今天，看了两位大神的博客，第一篇数独算法博客比我的妙多了，这是我的看法，首先，这篇博客让我知道了一个知识，看到的时候，我只能感慨自己的无知1List&lt;Integer&gt;[][] dataLeft = new ArrayList[9][9]; 就是上面这一句代码，让我突然间醒悟，原来数组还可以这样子用，或者说，之前int[9][9]局限了我的思维，我一直以为二维数组，只能填入数字，直到这句代码的出现，才知道，原来二维数组还可以这样子用。作者解数独的思维其实很简单，他创建了一个二维数组（A），每个坐标存储的是一个list，当然这个二维数组对应了另一个二维数组（数独数组：B），作者初始化A数组的时候，为每个坐标的list添加了数字1-9，即每个数独坐标可填入的所有数字。然后，作者从第一个坐标位开始判断，如果数独有值，则清除A中该坐标的list，并且清除该坐标行、列、宫所有list的这个值，1、最后判断A数组中所有list的长度，如果为1，表示找到一个正解，2、而长度不是1的，则判断行、列、宫内是否只出现了一次，如果是，获得一个正解3、最后判断单个宫内（可填值list长度不为1的），某个数字如果只在某一行（或者某一列）出现，那么可以排除另外两个宫，该行（或该列），无法填入该值A作者数独算法博客链接 另外一位大神则是回溯法解数独，简单点说，就是从第一个需要解值的位置开始，随意填入一个可填入的数字，然后下一个位置也是如此，一直填下去，如果出现错误，则回溯，如果没有，一直下去，直到解出数独。当然，核心还是对于行列宫的判断B作者数独算法博客链接 内心独白这两个算法都让我深深收到打击，不要说这么悲伤的事实，我还是有很大进步空间的。然后，你奇怪我为什么A大神写那么多，B大神写那么少，虽然算法都比我厉害，但是我个人还是觉得回溯法厉害一点，暴力的美学，深度优先的优雅，你值得拥有。 最后回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试，也叫试探法，我决定深度研究一下这个算法。 寄语有时候我们执着于自己的骄傲，却不知道，这恰恰局限了未来","tags":[{"name":"数独","slug":"数独","permalink":"http://yueshengwujie.cn/tags/数独/"},{"name":"算法","slug":"算法","permalink":"http://yueshengwujie.cn/tags/算法/"}]},{"title":"学习博客收集","date":"2017-03-07T09:52:48.000Z","path":"2017/03/07/学习博客收集/","text":"前端Emmet: HTML/CSS代码快速编写神器颜色表及html代码js中Math.random()生成指定范围数值的随机数 java使用Spring MVC,Mybatis框架等创建Java Web项目时各种前期准备的配置文件内容Maven仓库配置（全）java日志处理组件log4j–log4j.xml配置详解JAVA中经典快捷键(必看)和一些程序代码Java编码优化10技巧 c#C#中Abstract和VirtualJava程序员的C#入门教程 - 开发环境搭建 giteclipse中git分支创建与合并（-）[Git高级教程 (一)] 通过Tag标签回退版本修复bug PostgreSQL关于PreparedStatement.addBatch()方法（事务）PostgreSQL学习手册(SQL语言函数)PostgreSQL函数如何返回数据集PostgreSQL学习手册(函数和操作符&lt;一&gt;) other聚合数据–手机固话来电显示多渠道获取手机归属地PM25天气信息开发APIm12 安装ubuntu15.10详细图文教程 虚拟机安装ubuntu安装 ubuntu更新软件 ubuntu一直卡在下载语言怎么办? 寄语很多人说成长是在抛弃以前懵懂无知的天真，其实不过是在不断的把自己变得复杂","tags":[{"name":"工具","slug":"工具","permalink":"http://yueshengwujie.cn/tags/工具/"}]},{"title":"hexo笔记","date":"2017-03-07T02:12:49.000Z","path":"2017/03/07/hexo笔记/","text":"开始的开始一开始成为javaer，并不知道有个人博客的这种东西。后来入行了，慢慢了解更多，知道了有个人博客，然而并没有觉得自己也需要一个属于自己的博客。只是突然间，在16年初，和朋友好奇之下买了域名，用github搭建了一个个人博客。而当时我的博客，还是直接把别人的fork下来，然后放上去。懵懂无知的直接修改主页的内容，不知道需要去配置文件里面修改配置。弄着弄着，也就放弃了，可以说甚至还没有开始。 另一个开始这一段时间，收到了好多次阿里云域名快失效的邮件，从一开始的不愿意理会，到后来，不知怎的，就上去续了费，也是突然才记得，自己有一个已经开了一年的个人博客，于是，重新开始了个人博客之路，也许会夭折，但绝不是现在，也非常感谢一位大神提供的开源主题。传送门：大神的博客 正餐 环境工具：git,node.js,hexo,Sublime搭建过程：1、git里面Create a new repository（新建仓库），名字为git用户名.github.io，例如我的：yueshengwujie.github.io2、DNS绑定域名（网上教程），github中最简单做法，直接添加一个名为CNAME的文件（无后缀），里面直接填写域名3、配置SSH key，ssh-keygen -t rsa -C “邮件地址”生成密钥，找到用户目录下.ssh\\id_rsa.pub文件，直接打开复制内容到github中的个人设置 -&gt; SSH and GPG keys -&gt; New SSH key4、git bash中操作指令(随便一个文件目录下操作)123456$ npm install -g hexo # 安装hexo$ hexo init # 初始化$ hexo g # 生成$ hexo s # 启动服务，本地浏览器访问[http://localhost:4000]$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia # 下载主题，个人比较喜欢的主题，也是我现在的主题$ hexo d # 发布上传到git 5、配置文件的修改主目录的_config.yml配置文件的修改1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia # 主题修改，将主题修改为theme目录下你喜欢的主题的文件夹的名字 下面配置关联github与本地仓库1234deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git # 注意使用git ssh，不要用https branch: master # 注意每个配置键值之间有一个空格分开 配置好以后安装一个必备插件1npm install hexo-deployer-git --save 6、常用的hexo命令12345678910111213$ hexo new &quot;postName&quot; #新建文章$ hexo new page &quot;pageName&quot; #新建页面$ hexo generate #生成静态页面至public目录$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）$ hexo deploy #部署到GitHub$ hexo help # 查看帮助$ hexo version #查看Hexo的版本# 缩写$ hexo n == $ hexo new$ hexo g == $ hexo generate$ hexo s == $ hexo server$ hexo d == $ hexo deploy 7、关于_config.yml配置文件的修改该配置文件在主目录下有一个，在themes/yilia目录下也有一个，后一个是相关于主题的配置。如果要添加一些静态资源，如图片，可以回到根目录下的source目录下添加一个文件夹photo，然后将图片放入，则可以在博客中使用”![图片描述](/photo/xxx.jpg)”直接插入 此篇博客只做简单的记录，关于一些详细的教程，相信网上已经有很多教程。个人配置参考源码 参考博文hexo博客添加图片，音乐，视频yilia主题源码Markdown 编辑器语法指南(Sublime)使用hexo+github搭建免费个人博客详细教程 寄语文字的美，不仅仅是文明的传承，更是镌刻着这个世界的曾经拥有","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yueshengwujie.cn/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://yueshengwujie.cn/tags/markdown/"}]},{"title":"真正开始的博客之路","date":"2017-03-06T10:01:28.000Z","path":"2017/03/06/真正开始的博客之路/","text":"寄语如果开始，那就不要轻易放弃，也许这就是梦想开始的地方","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yueshengwujie.cn/tags/随笔/"}]}]